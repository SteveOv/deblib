""" Unit tests for the task module/classes. """
# pylint: disable=protected-access
import unittest
from pathlib import Path
from os import environ
from io import StringIO
from string import Template
from subprocess import CalledProcessError

from deblib.jktebop.task import Task, Task2


class TaskTestSubclass(Task):
    """ A subclass of Task used for testing. """

class TestTask(unittest.TestCase):
    """ Unit tests for the task module/classes. """
    _jktebop_dir = Path(environ.get("JKTEBOP_DIR", "~/jktebop/")).expanduser().absolute()

    #
    # class: Task(ABC)
    #
    def test_task_init_happy_path(self):
        """ Test Task.__init__(happy path) """
        template = Template("")
        task = TaskTestSubclass(self._jktebop_dir, template)
        self.assertEqual(task.working_dir, self._jktebop_dir)
        self.assertEqual(task._template, template)
        self.assertEqual({}, task.default_params)

    def test_task_write_in_file_happy_path(self):
        """ Test Task._write_in_file() > file is written with token substitutions """
        in_file = self._jktebop_dir / "test_task_write_in_file_happy_path.in"
        task = TaskTestSubclass(self._jktebop_dir, Template("${t1} ${t2} t3"))
        params = { "t1": "#1", "t2": "#2", "t3": "#3" }
        task._write_in_file(in_file, params)

        self.assertTrue(in_file.exists())
        in_file_text = in_file.read_text(encoding="utf8")
        self.assertIn("#1", in_file_text, "expect to find #1 (t1) in in_file")
        self.assertIn("#2", in_file_text, "expect to find #2 (t2) in in_file")
        # t3 not in template & we expect t3 param to be ignored (no error)
        self.assertNotIn("#3", in_file_text, "not expected to find #3 (t3) in in_file")
        self.addCleanup(self.remove_file, in_file)

    def test_task_write_in_file_missing_param(self):
        """ Test Task._write_in_file(missing param) > KeyError """
        in_file = self._jktebop_dir / "test_task_write_in_file_missing_param.in"
        in_file.unlink(missing_ok=True)
        task = TaskTestSubclass(self._jktebop_dir, Template("${t1} ${t2} t3"))
        with self.assertRaises(KeyError) as ect:
            params = {"t2": "#2", "t3": "#3"}
            task._write_in_file(in_file, params)
            self.assertIn("t1", ect.exception.output)
        self.assertFalse(in_file.exists())
        self.addCleanup(self.remove_file, in_file)

    def test_task_run_happy_path(self):
        """ Test Task.run() > file is written with token substitutions """
        # Minimal template for a jktebop #2 (generate model light curve) task
        par_lines = ["2    5", "0.3  0.5", "90.0 1.0", "0.0  0.0", "0.0  0.0", "0.5  0.0",
                     "quad same", "0.38 0", "0.38 0", "-100 -100", "0    0", "${out_file_name}"]
        task = TaskTestSubclass(self._jktebop_dir, Template("\n".join(par_lines)))

        # The in file will be generated by run() from the Task's template and these params
        in_file = self._jktebop_dir / "test_task_run_happy_path.in"
        out_file = self._jktebop_dir / f"{in_file.stem}.out"
        params = { "out_file_name": out_file.name }
        stdout_to = StringIO()

        # run() generates the in file, runs jktebop against it (sending console to stdout_to) and...
        lines = list(task.run(params, file_stem=in_file.stem, primary_result_file_ext="out",
                              do_cleanup=True, raise_warnings=True, stdout_to=stdout_to))

        # ...if successful, writes an out file with ~10k lines, yields each line & deletes the files
        self.assertTrue(len(lines) > 1000)
        self.assertIn(f"Opened new lightcurve file:  {out_file.name}", stdout_to.getvalue())
        self.assertFalse(out_file.exists())

        self.addCleanup(self.remove_file, in_file)
        self.addCleanup(self.remove_file, out_file)

    def test_task2_run_and_read_light_curve_happy_path(self):
        """ Test Task2.generate_model_light_curve(happy path) """
        task = Task2(self._jktebop_dir)

        # We don't need to pass in anything for those params where the default is to be used
        params = {
            # These don't have defaults and must be set
            "sumr": 0.3,    "k": 0.5,
            "inc": 90,
            "J": 0.5,
            "ecosw": 0.0,   "esinw": 0.0
        }

        # Will generate an in file with unique temp name, run the task, parse the primary output
        model = task.run_and_read_light_curve(params, "test_task2_happy_path_")

        self.assertTrue(model.shape[0] > 1000)  # it's usually 10001
        self.assertIn("phase", model.dtype.names)
        self.assertIn("delta_mag", model.dtype.names)

    def test_task2_run_and_read_light_curve_invalid_param_value(self):
        """ Test Task2.generate_model_light_curve() LDA invalid -> expect error """
        task = Task2(self._jktebop_dir)
        file_prefix = "test_task2_invalid_param_value_"

        params = {
            "sumr": 0.3,    "k": 0.5,
            "inc": 0.0,     # <-- not a valid value (range is 50 to 140)
            "J": 0.0,
            "ecosw": 0.0,   "esinw": 0.0,
        }

        with self.assertRaises(CalledProcessError) as ect:
            task.run_and_read_light_curve(params, file_prefix)
        self.assertIn("ERROR: the value of INCLNATION", ect.exception.output)

        for in_file in self._jktebop_dir.glob(f"{file_prefix}*.in"):
            self.addCleanup(self.remove_file, in_file)


    # Helpers
    def remove_file(self, file: Path):
        """ Will remove the indicated file if it exists. """
        file.unlink(missing_ok=True)


if __name__ == '__main__':
    unittest.main()
