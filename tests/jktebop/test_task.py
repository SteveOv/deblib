""" Unit tests for the task module/classes. """
# pylint: disable=protected-access
import unittest
from pathlib import Path
from shutil import copy
from inspect import getsourcefile
from os import environ
from io import StringIO
from string import Template
from subprocess import CalledProcessError

from deblib.jktebop.task import Task, Task2, Task3

_this_dir = Path(getsourcefile(lambda:0)).parent

class TaskTestSubclass(Task):
    """ A subclass of Task used for testing. """

class TestTask(unittest.TestCase):
    """ Unit tests for the task module/classes. """
    _jktebop_dir = Path(environ.get("JKTEBOP_DIR", "~/jktebop/")).expanduser().absolute()

    # --------------------------------------------------------------------------
    # class: Task(ABC)
    # --------------------------------------------------------------------------
    def test_task_init_happy_path(self):
        """ Test Task.__init__(happy path) """
        template = Template("")
        task = TaskTestSubclass(self._jktebop_dir, template)
        self.assertEqual(task.working_dir, self._jktebop_dir)
        self.assertEqual(task._template, template)
        self.assertEqual({}, task.default_params)

    def test_task_write_in_file_happy_path(self):
        """ Test Task._write_in_file() > file is written with token substitutions """
        in_file = self._jktebop_dir / "test_task_write_in_file_happy_path.in"
        task = TaskTestSubclass(self._jktebop_dir, Template("${t1} ${t2} t3"))
        params = { "t1": "#1", "t2": "#2", "t3": "#3" }
        task._write_in_file(in_file, params)

        self.assertTrue(in_file.exists())
        in_file_text = in_file.read_text(encoding="utf8")
        self.assertIn("#1", in_file_text, "expect to find #1 (t1) in in_file")
        self.assertIn("#2", in_file_text, "expect to find #2 (t2) in in_file")
        # t3 not in template & we expect t3 param to be ignored (no error)
        self.assertNotIn("#3", in_file_text, "not expected to find #3 (t3) in in_file")
        self.addCleanup(self.remove_file, in_file)

    def test_task_write_in_file_missing_param(self):
        """ Test Task._write_in_file(missing param) > KeyError """
        in_file = self._jktebop_dir / "test_task_write_in_file_missing_param.in"
        in_file.unlink(missing_ok=True)
        task = TaskTestSubclass(self._jktebop_dir, Template("${t1} ${t2} t3"))
        with self.assertRaises(KeyError) as ect:
            params = {"t2": "#2", "t3": "#3"}
            task._write_in_file(in_file, params)
            self.assertIn("t1", ect.exception.output)
        self.assertFalse(in_file.exists())
        self.addCleanup(self.remove_file, in_file)

    def test_task_run_happy_path(self):
        """ Test Task.run() > file is written with token substitutions """
        # Minimal template for a jktebop #2 (generate model light curve) task
        par_lines = ["2    5", "0.3  0.5", "90.0 1.0", "0.0  0.0", "0.0  0.0", "0.5  0.0",
                     "quad same", "0.38 0", "0.38 0", "-100 -100", "0    0", "${out_file_name}"]
        task = TaskTestSubclass(self._jktebop_dir, Template("\n".join(par_lines)))

        # The in file will be generated by run() from the Task's template and these params
        in_file = self._jktebop_dir / "test_task_run_happy_path.in"
        out_file = self._jktebop_dir / f"{in_file.stem}.out"
        params = { "out_file_name": out_file.name }
        stdout_to = StringIO()

        # run() generates the in file, runs jktebop against it (sending console to stdout_to) and...
        lines = list(task.run(params, file_stem=in_file.stem, primary_result_file_ext="out",
                              do_cleanup=True, raise_warnings=True, stdout_to=stdout_to))

        # ...if successful, writes an out file with ~10k lines, yields each line & deletes the files
        self.assertTrue(len(lines) > 1000)
        self.assertIn(f"Opened new lightcurve file:  {out_file.name}", stdout_to.getvalue())
        self.assertFalse(out_file.exists())

        self.addCleanup(self.remove_file, in_file)
        self.addCleanup(self.remove_file, out_file)


    # --------------------------------------------------------------------------
    # class: Task2(Task) / generate model light curve from params
    # --------------------------------------------------------------------------
    def test_task2_run_and_read_light_curve_happy_path(self):
        """ Test Task2.generate_model_light_curve(happy path) """
        task = Task2(self._jktebop_dir)

        # We don't need to pass in anything for those params where the default is to be used
        params = {
            # These don't have defaults and must be set
            "sumr": 0.3,    "k": 0.5,
            "inc": 90,
            "J": 0.5,
            "ecosw": 0.0,   "esinw": 0.0
        }

        # Will generate an in file with unique temp name, run the task, parse the primary output
        model = task.run_and_read_light_curve(params, "test_task2_happy_path_")

        self.assertTrue(model.shape[0] > 1000)  # it's usually 10001
        self.assertIn("phase", model.dtype.names)
        self.assertIn("delta_mag", model.dtype.names)

    def test_task2_run_and_read_light_curve_invalid_param_value(self):
        """ Test Task2.generate_model_light_curve() LDA invalid -> expect error """
        task = Task2(self._jktebop_dir)
        file_prefix = "test_task2_invalid_param_value_"

        params = {
            "sumr": 0.3,    "k": 0.5,
            "inc": 0.0,     # <-- not a valid value (range is 50 to 140)
            "J": 0.0,
            "ecosw": 0.0,   "esinw": 0.0,
        }

        with self.assertRaises(CalledProcessError) as ect:
            task.run_and_read_light_curve(params, file_prefix)
        self.assertIn("ERROR: the value of INCLNATION", ect.exception.output)

        for in_file in self._jktebop_dir.glob(f"{file_prefix}*.in"):
            self.addCleanup(self.remove_file, in_file)


    # --------------------------------------------------------------------------
    # class: Task3(Task) / fit light curve data
    # --------------------------------------------------------------------------
    def test_task3_run_against_cw_eri_full_happy_path(self):
        """ Test Task3.run(on CW Eri data and full set of params for good fit) """
        task = Task3(self._jktebop_dir)

        file_stem = "test-t3-full-cw-eri"
        test_dat_file = self.copy_file(_this_dir / "data/cw-eri-s31-pt1-binned.dat",
                                       task.working_dir / f"{file_stem}.dat")

        params = { # Complete set of explicitly set task 3 fitting params for CW Eri
            "task": 3,              "ring": 5,
            "sumr": 0.30,           "k": 0.70,
            "inc": 85.5,            "qphot": 0.836,
            "ecosw": 0.005,         "esinw": -0.012,
            "gravA": 0.0,           "gravB": 0.0,
            "J": 0.92,              "L3": 0.0,
            "LDA": "pow2",          "LDB": "pow2",
            "LDA1": 0.6437,         "LDB1": 0.6445,
            "LDA2": 0.4676,         "LDB2": 0.4967,
            "reflA": 0.0,           "reflB": 0.0,
            "phiP": 0.0,            "sf": 0.0,
            "period": 2.728371,
            "TP": 2152.144,
            "simulations": "",
            "sumr_fit": 1,          "k_fit": 1,
            "inc_fit": 1,           "qphot_fit": 0,
            "ecosw_fit": 1,         "esinw_fit": 1,
            "gravA_fit": 0,         "gravB_fit": 0,
            "J_fit": 1,             "L3_fit": 1,
            "LDA1_fit": 1,          "LDB1_fit": 1,
            "LDA2_fit": 0,          "LDB2_fit": 0,
            "reflA_fit": 1,         "reflB_fit": 1,
            "phiP_fit": 0,          "sf_fit": 1,
            "per_fit": 1,           "TP_fit": 1,

            "data_file_name": test_dat_file.name,
            "out_file_stem": file_stem,

            "rv1": "",              "rv2": "",
            "do": "chif",           "lrats": "",
            "polies": "poly  sf  2150.595  0.0 0.0 0.0 0.0 0.0 0.0  1 1 0 0 0 0  2144.520 2156.670"
        }

        # Run the task and capture to contents of the par file, which will hold the fitted values
        success = False
        for line in task.run(params, file_stem=file_stem, primary_result_file_ext="par",
                             do_cleanup=True, raise_warnings=True, stdout_to=None):
            if "iterations of EBOP completed" in line:
                success = True # Don't break here or the cleanup will not happen

        self.assertTrue(success, "Expected success == True")
        self.addCleanup(self.remove_file, test_dat_file)

    def test_task3_run_against_cw_eri_minimal_happy_path(self):
        """ Test Task3.run(CW Eri data and minmal params, and defaults where OK, for good fit) """
        task = Task3(self._jktebop_dir)

        file_stem = "test-t3-minimal-cw-eri"
        test_dat_file = self.copy_file(_this_dir / "data/cw-eri-s31-pt1-binned.dat",
                                       task.working_dir / f"{file_stem}.dat")

        params = { # Minimal set of 3 fitting params (those without usable defaults) for CW Eri
            "sumr": 0.30,           "k": 0.70,
            "inc": 85.5,            "qphot": 0.836,
            "ecosw": 0.005,         "esinw": -0.012,
            "J": 0.92,
            "LDA": "pow2",          "LDB": "pow2",
            "LDA1": 0.6437,         "LDB1": 0.6445,
            "LDA2": 0.4676,         "LDB2": 0.4967,
            "period": 2.728371,
            "TP": 2152.144,

            "data_file_name": test_dat_file.name,
            "out_file_stem": file_stem,

            "do": "chif",
            "polies": "poly  sf  2150.595  0.0 0.0 0.0 0.0 0.0 0.0  1 1 0 0 0 0  2144.520 2156.670"
        }

        # Run the task and capture to contents of the par file, which will hold the fitted values
        success = False
        for line in task.run(params, file_stem=file_stem, primary_result_file_ext="par",
                             do_cleanup=True, raise_warnings=True, stdout_to=None):
            if "iterations of EBOP completed" in line:
                success = True # Don't break here or the cleanup will not happen

        self.assertTrue(success, "Expected success == True")
        self.addCleanup(self.remove_file, test_dat_file)


    # --------------------------------------------------------------------------
    # Helpers
    # --------------------------------------------------------------------------
    def copy_file(self, source_file: Path, dest: Path) -> Path:
        """ Copy the source file to the destination and return the destination file """
        if dest.is_dir():
            dest /= source_file.name
        self.remove_file(dest)
        copy(source_file, dest)
        return dest

    def remove_file(self, file: Path):
        """ Will remove the indicated file if it exists. """
        file.unlink(missing_ok=True)


if __name__ == '__main__':
    unittest.main()
